use bevy::{prelude::*, render::render_resource::Texture, utils::HashMap};
use itertools::Itertools;
use rand::prelude::*;

fn face_value_map() -> HashMap<String, u8> {
    let faces = vec![
        "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A",
    ];
    let values = 2..=14;

    faces
        .into_iter()
        .zip(values)
        .map(|(face, value)| (face.to_string(), value))
        .collect()
}

fn display_card(card: &Card) -> String {
    let suit = card.0.clone();
    let card = card.1.as_str();
    match card {
        "J" => format!("Jack of {}", suit).to_string(),
        "Q" => format!("Queen of {}", suit).to_string(),
        "K" => format!("King of {}", suit).to_string(),
        "A" => format!("Ace of {}", suit).to_string(),
        card => format!("{} of {}", card, suit).to_string(),
    }
}

fn value_face_reverse_map() -> HashMap<u8, String> {
    let faces = vec![
        "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A",
    ];
    let values = 2..=14;

    faces
        .into_iter()
        .zip(values)
        .map(|(face, value)| (value, face.to_string()))
        .collect()
}

#[derive(Debug, Clone)]
pub struct Card(String, String, u8);

fn face_cards() -> impl Iterator<Item = Card> {
    let face_value = face_value_map();
    vec![
        vec!["Clubs", "Diamonds", "Hearts", "Spades"],
        vec![
            "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A",
        ],
    ]
    .into_iter()
    .map(|x| {
        x.into_iter()
            .map(|x| x.to_string())
            .collect::<Vec<String>>()
    })
    .multi_cartesian_product()
    .map(move |pair| {
        // pattern match Vec<String> of length 2
        let [suit, value]: [String; 2] = pair.try_into().expect("Expected a pair");
        Card(
            suit,
            value.clone(),
            face_value.get(&value).unwrap().to_owned().clone(),
        )
    })
}

#[derive(Component, Default)]
struct PlayerNum(u8);

#[derive(Component, Debug, Clone)]
#[require(PlayerNum)]
struct Player {
    cards: Vec<Card>,
}

fn initial_cards() -> Vec<Card> {
    let mut rng = rand::rng(); // Create a thread-local RNG

    let mut cards = face_cards().collect::<Vec<Card>>();
    cards.shuffle(&mut rng);
    cards
}

fn distribute_cards(players: &mut Vec<Player>, cards: Vec<Card>) {
    for player in players.iter_mut() {
        player.cards.clear();
    }

    for (i, card) in cards.into_iter().enumerate() {
        let player_index = i % players.len();
        players[player_index].cards.push(card);
    }
}

fn init_players(mut commands: Commands) {
    // Maybe make this a resource
    let num_players = 2;
    let mut players = Vec::new();
    for player in 0..num_players {
        players.push((Player { cards: Vec::new() }, PlayerNum(player)));
    }

    distribute_cards(
        &mut players
            .iter_mut()
            .map(|x| x.0
            .collect::<Vec<Player>>(),
        initial_cards(),
    );

    for player in players {
        commands.spawn(player);
    }
}

#[derive(Component)]
struct PlayerArea;
#[derive(Component)]
struct DeckArea;
#[derive(Component)]
struct CurrentCardArea;

fn setup_ui(mut commands: Commands, asset_server: Res<AssetServer>) {
    commands.spawn(Camera2dBundle::default());

    commands
        .spawn((
            Node {
                flex_direction: FlexDirection::Column,
                height: Val::Percent(100.),
                width: Val::Percent(100.),
                justify_content: JustifyContent::SpaceBetween,
                align_items: AlignItems::Stretch,
                ..default()
            },
            BackgroundColor::from(Color::srgb(0.3, 0.3, 0.3)),
        ))
        .with_children(|parent| {
            let font = asset_server.load("fonts/FiraMono-Medium.ttf");
            let image = asset_server.load("kenney_boardgame-pack/PNG/Cards/cardSpadesA.png");
            // Top Player (Player 2)
            spawn_player_ui(
                parent,
                String::from("Player 2"),
                font.clone(),
                image.clone(),
                asset_server.load("kenney_boardgame-pack/PNG/Cards/cardBack_blue5.png"),
                FlexDirection::RowReverse,
            );

            // Bottom Player (Player 1)
            spawn_player_ui(
                parent,
                String::from("Player 1"),
                font,
                image,
                asset_server.load("kenney_boardgame-pack/PNG/Cards/cardBack_green5.png"),
                FlexDirection::Row,
            );
        });
}

fn spawn_player_ui(
    parent: &mut ChildBuilder,
    name: String,
    font: Handle<Font>,
    image: Handle<Image>,
    back_image: Handle<Image>,
    flex_direction: FlexDirection,
) {
    parent
        .spawn((Node {
            margin: UiRect::all(Val::Px(10.0)),
            flex_direction,
            column_gap: Val::Px(20.),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },))
        .with_children(|player_area| {
            // Deck
            player_area.spawn((
                Node {
                    width: Val::Px(140.0),
                    height: Val::Px(190.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    ..default()
                },
                ImageNode {
                    image: back_image,
                    ..default()
                },
                DeckArea,
            ));

            // Current Card
            player_area.spawn((
                Node {
                    width: Val::Px(140.),
                    height: Val::Px(190.),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    ..default()
                },
                ImageNode { image, ..default() },
                CurrentCardArea,
            ));

            // Player Label
            player_area.spawn(()).with_children(|text_area| {
                text_area.spawn((
                    Text(name),
                    TextFont {
                        font: font.clone(),
                        font_size: 20.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                    Node {
                        margin: UiRect::all(Val::Px(10.)),
                        ..default()
                    },
                ));

                text_area
                    .spawn((
                        Text(String::from("Cards Left: ")),
                        TextFont {
                            font: font.clone(),
                            font_size: 20.0,
                            ..default()
                        },
                        TextColor(Color::WHITE),
                        Node {
                            margin: UiRect::all(Val::Px(10.)),
                            ..default()
                        },
                    ))
                    .with_children(|text| {
                        text.spawn((
                            TextSpan::default(),
                            TextFont {
                                font: font.clone(),
                                font_size: 20.0,
                                ..default()
                            },
                            TextColor(Color::WHITE),
                            Node {
                                margin: UiRect::all(Val::Px(10.)),
                                ..default()
                            },
                        ));
                    });
            });
        });
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, (init_players, setup_ui))
        .run();
}
